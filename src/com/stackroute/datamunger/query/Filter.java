package com.stackroute.datamunger.query;

import com.stackroute.datamunger.query.parser.QueryParameter;
import com.stackroute.datamunger.query.parser.Restriction;

//this class contains methods to evaluate expressions
public class Filter {

	/*
	 * the evaluateExpression() method of this class is responsible for evaluating
	 * the expressions mentioned in the query. It has to be noted that the process
	 * of evaluating expressions will be different for different data types. there
	 * are 6 operators that can exist within a query i.e. >=,<=,<,>,!=,= This method
	 * should be able to evaluate all of them. Note: while evaluating string
	 * expressions, please handle uppercase and lowercase
	 * 
	 */
	public Row evaluateExpression(QueryParameter queryParameter, Row row) {
		Row finalRowMap = null;
		if (null == queryParameter) {
			return finalRowMap;
		}
		boolean finalResult = false;
		if (null != queryParameter.getRestrictions() && !queryParameter.getRestrictions().isEmpty()) {
			int index = null != queryParameter.getLogicalOperators() ? queryParameter.getLogicalOperators().size() - 1
					: 0;
			String logicalOp = "or";
			/*
			 * from QueryParameter object, read one condition at a time and evaluate the
			 * same. For evaluating the conditions, we will use evaluateExpressions() method
			 * of Filter class. Please note that evaluation of expression will be done
			 * differently based on the data type of the field. In case the query is having
			 * multiple conditions, you need to evaluate the overall expression i.e. if we
			 * have OR operator between two conditions, then the row will be selected if any
			 * of the condition is satisfied. However, in case of AND operator, the row will
			 * be selected only if both of them are satisfied.
			 */
			for (int i = queryParameter.getRestrictions().size() - 1; i >= 0; i--) {
				final Restriction restriction = queryParameter.getRestrictions().get(i);
				boolean result = false;
				final String value = row.get(restriction.getPropertyName());
				switch (restriction.getCondition()) {
				case "=":
					result = this.equalsTo(restriction.getPropertyValue(), value);
					break;
				case "!=":
					result = !this.equalsTo(restriction.getPropertyValue(), value);
					break;
				case ">":
					result = this.greaterThan(restriction.getPropertyValue(), value);
					break;
				case "<":
					result = this.lessThan(restriction.getPropertyValue(), value);
					break;
				case "<=":
					result = (this.lessThan(restriction.getPropertyValue(), value)
							|| this.equalsTo(restriction.getPropertyValue(), value));
					break;
				case ">=":
					result = (this.equalsTo(restriction.getPropertyValue(), value)
							|| this.greaterThan(restriction.getPropertyValue(), value));
					break;
				default:
					break;
				}

				/*
				 * check for multiple conditions in where clause for eg: where salary>20000 and
				 * city=Bangalore for eg: where salary>20000 or city=Bangalore and dept!=Sales
				 */
				if ("and".equals(logicalOp)) {
					finalResult = finalResult && result;
				} else if ("or".matches(logicalOp)) {
					finalResult = finalResult || result;
				}
				if (null != queryParameter.getLogicalOperators() && !queryParameter.getLogicalOperators().isEmpty()
						&& index >= 0) {
					logicalOp = queryParameter.getLogicalOperators().get(index);
					index--;
				}
			}
		} else {
			finalResult = true;
		}

		/**
		 * if the overall condition expression evaluates to true, then we need to check
		 * if all columns are to be selected(select *) or few columns are to be
		 * selected(select col1,col2). In either of the cases, we will have to populate
		 * the row map object. 
		 */
		/**Row Map object is having type <String,String> to contain
		 * field Index and field value for the selected fields. Once the row object is
		 * populated, add it to DataSet Map Object. DataSet Map object is having type
		 * <Long,Row> to hold the rowId (to be manually generated by incrementing a Long
		 * variable) and it's corresponding Row Object.
		 */ 
		if (finalResult) {
			finalRowMap = new Row();
			if (null != queryParameter.getFields() && !queryParameter.getFields().isEmpty()) {
				for (final String fields : queryParameter.getFields()) {
					if ("*".equals(fields)) {
						finalRowMap.putAll(row);
						break;
					}
					String value = null;
					if (null != (value = row.get(fields))) {
						finalRowMap.put(fields, value);
					}
				}
			}
		}
		return finalRowMap;
	}

	// method containing implementation of equalTo operator
	private boolean equalsTo(String value1, String value2) {
		if (null == value1 && null == value2) {
			return true;
		}
		if (null == value1 || null == value2) {
			return false;
		}

		return value1.equalsIgnoreCase(value2);
	}

	// method containing implementation of notEqualTo operator
	// Not Required.
	/*
	 * private boolean notEqualsTo(String value1, String value2) { if (null ==
	 * value1 && null == value2) { return false; } if (null == value1 || null ==
	 * value2) { return true; }
	 * 
	 * return !(value1.equalsIgnoreCase(value2)); }
	 */

	// method containing implementation of greaterThan operator
	private boolean greaterThan(String restrictionVal, String dataVal) {
		if (null == restrictionVal || null == dataVal) {
			return false;
		}

		try {
			int restriction = Integer.parseInt(restrictionVal);
			int data = Integer.parseInt(dataVal);
			return data > restriction;
		} catch (NumberFormatException e) {
			// TODO: handle exception
			return false;
		}
	}

	// method containing implementation of greaterThanOrEqualTo operator

	// method containing implementation of lessThan operator
	private boolean lessThan(String restrictionVal, String dataVal) {
		if (null == restrictionVal || null == dataVal) {
			return false;
		}

		try {
			int restriction = Integer.parseInt(restrictionVal);
			int data = Integer.parseInt(dataVal);
			return data < restriction;
		} catch (NumberFormatException e) {
			// TODO: handle exception
			return false;
		}
	}
	// method containing implementation of lessThanOrEqualTo operator

}
